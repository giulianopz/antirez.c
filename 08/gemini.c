#include <stdio.h>    
#include <stdlib.h>   
#include <stdbool.h>  
#include <time.h>     
#include <unistd.h>   
#include <sys/ioctl.h> 
#include <termios.h>   

/* 
    C port of Go implentation available in the playgroung (https://go.dev/play/).
    This code was generated by Gemini 2.5 asking it to use max window size using ioctl.
 */


// Field represents a two-dimensional field of cells.
typedef struct Field {
    bool **s; 
    int w, h; 
} Field;

// Function to create a new Field and allocate memory for its cells.
// Returns a pointer to the newly created Field.
Field* NewField(int w, int h) {
    Field *f = (Field*) malloc(sizeof(Field));
    if (f == NULL) {
        perror("Failed to allocate Field");
        exit(EXIT_FAILURE);
    }
    f->w = w;
    f->h = h;

    
    f->s = (bool**) malloc(h * sizeof(bool*));
    if (f->s == NULL) {
        perror("Failed to allocate rows for Field");
        free(f);
        exit(EXIT_FAILURE);
    }

    
    for (int i = 0; i < h; i++) {
        f->s[i] = (bool*) malloc(w * sizeof(bool));
        if (f->s[i] == NULL) {
            perror("Failed to allocate columns for Field row");
            
            for (int j = 0; j < i; j++) {
                free(f->s[j]);
            }
            free(f->s);
            free(f);
            exit(EXIT_FAILURE);
        }
        
        for (int j = 0; j < w; j++) {
            f->s[i][j] = false;
        }
    }
    return f;
}

// Function to free the memory allocated for a Field.
void FreeField(Field *f) {
    if (f == NULL) return;
    for (int i = 0; i < f->h; i++) {
        free(f->s[i]); 
    }
    free(f->s); 
    free(f);    
}

// Set sets the state of the specified cell to the given value.
void Field_Set(Field *f, int x, int y, bool b) {
    
    if (x >= 0 && x < f->w && y >= 0 && y < f->h) {
        f->s[y][x] = b;
    }
}

// Alive reports whether the specified cell is alive.
// If the x or y coordinates are outside the field boundaries they are wrapped
// toroidally. For instance, an x value of -1 is treated as width-1.
bool Field_Alive(Field *f, int x, int y) {
    x = (x % f->w + f->w) % f->w;
    y = (y % f->h + f->h) % f->h;
    return f->s[y][x];
}

// Next returns the state of the specified cell at the next time step.
bool Field_Next(Field *f, int x, int y) {
    int alive_neighbors = 0;
    for (int i = -1; i <= 1; i++) {
        for (int j = -1; j <= 1; j++) {
            
            if ((j != 0 || i != 0) && Field_Alive(f, x + i, y + j)) {
                alive_neighbors++;
            }
        }
    }
    return alive_neighbors == 3 || (alive_neighbors == 2 && Field_Alive(f, x, y));
}

// Life stores the state of a round of Conway's Game of Life.
typedef struct Life {
    Field *a, *b; 
    int w, h;     
} Life;

// NewLife returns a new Life game state with a random initial state.
Life* NewLife(int w, int h) {
    Life *l = (Life*) malloc(sizeof(Life));
    if (l == NULL) {
        perror("Failed to allocate Life");
        exit(EXIT_FAILURE);
    }
    l->w = w;
    l->h = h;
    l->a = NewField(w, h); 
    l->b = NewField(w, h); 

    srand(time(NULL));

    for (int i = 0; i < (w * h / 4); i++) {
        Field_Set(l->a, rand() % w, rand() % h, true);
    }
    return l;
}

// Function to free the memory allocated for a Life game.
void FreeLife(Life *l) {
    if (l == NULL) return;
    FreeField(l->a); 
    FreeField(l->b); 
    free(l);         
}

// Step advances the game by one instant, recomputing and updating all cells.
void Life_Step(Life *l) {
    for (int y = 0; y < l->h; y++) {
        for (int x = 0; x < l->w; x++) {
            Field_Set(l->b, x, y, Field_Next(l->a, x, y));
        }
    }
    
    Field *temp = l->a;
    l->a = l->b;
    l->b = temp;
}

// Life_PrintBoard prints the game board to stdout.
void Life_PrintBoard(Life *l) {
    
    printf("\033[H\033[2J");

    for (int y = 0; y < l->h; y++) {
        for (int x = 0; x < l->w; x++) {
            char cell_char = ' '; 
            if (Field_Alive(l->a, x, y)) {
                cell_char = '*'; 
            }
            putchar(cell_char); 
        }
        putchar('\n'); 
    }
    fflush(stdout); 
}

// Function to get terminal window size using ioctl
void get_terminal_size(int *width, int *height) {
    struct winsize ws;
    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == -1) {
        perror("ioctl failed to get terminal size");
        
        *width = 80;
        *height = 24;
    } else {
        *width = ws.ws_col;
        *height = ws.ws_row - 1;
        
        if (*width < 10) *width = 10;
        if (*height < 5) *height = 5;
    }
}

int main() {
    int board_width;
    int board_height;
    get_terminal_size(&board_width, &board_height);
    
    Life *game = NewLife(board_width, board_height);
    for (;;) {
        Life_Step(game);           
        Life_PrintBoard(game);     
        usleep(1000000 / 30);      
    }

    FreeLife(game);

    return 0;
}
